'use client';

import { poseidon2Hash } from '@aztec/foundation/crypto';

// BN254 scalar field modulus
const BN254_SCALAR_FIELD_MODULUS = BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617');

// Minimum tree depth (must match contract)
const MIN_TREE_DEPTH = 8;

/**
 * Reduce a bigint to the BN254 scalar field
 */
function reduceToField(value: bigint): bigint {
    return value % BN254_SCALAR_FIELD_MODULUS;
}

/**
 * Convert Aztec hash result to bigint
 */
function toBigInt(result: any): bigint {
    if (typeof result === 'bigint') {
        return result;
    } else if ('toBigInt' in result && typeof result.toBigInt === 'function') {
        return result.toBigInt();
    } else if ('value' in result) {
        return BigInt(result.value);
    } else {
        return BigInt(result.toString());
    }
}

/**
 * Poseidon2 hash using Aztec Foundation
 */
async function poseidon2HashAsync(inputs: bigint[]): Promise<bigint> {
    const result = await poseidon2Hash(inputs.map(reduceToField));
    return reduceToField(toBigInt(result));
}

/**
 * Lean IMT implementation that matches the Solidity contract exactly
 * Uses incremental insertion with sideNodes, just like the contract
 */
export class LeanIMTContract {
    sideNodes: bigint[];
    leaves: bigint[];
    root: bigint;
    depth: number;
    size: number;

    constructor() {
        this.sideNodes = new Array(33).fill(BigInt(0));
        this.leaves = [];
        this.root = BigInt(0);
        this.depth = 0;
        this.size = 0;
    }

    /**
     * Insert a leaf - matches LeanIMTPoseidon2._insert exactly
     */
    async insert(leaf: bigint): Promise<bigint> {
        const index = this.size;

        // Calculate tree depth
        let treeDepth = this.depth;
        if (2 ** treeDepth < index + 1) {
            treeDepth++;
        }

        // Ensure minimum depth of 8 (matches contract)
        if (treeDepth < MIN_TREE_DEPTH) {
            treeDepth = MIN_TREE_DEPTH;
        }

        this.depth = treeDepth;

        let node = leaf;

        for (let level = 0; level < treeDepth; level++) {
            if (((index >> level) & 1) === 1) {
                // Right child: hash(sideNodes[level], node)
                node = await poseidon2HashAsync([this.sideNodes[level], node]);
            } else {
                // Left child: save current node to sideNodes
                this.sideNodes[level] = node;
            }
        }

        this.size = index + 1;
        this.sideNodes[treeDepth] = node;
        this.leaves.push(leaf);
        this.root = node;

        return node;
    }

    /**
     * Build tree from array of leaves
     */
    async buildFromLeaves(leaves: bigint[]): Promise<void> {
        for (const leaf of leaves) {
            await this.insert(leaf);
        }
    }

    /**
     * Generate merkle proof for a leaf at a given index
     * The proof is generated by simulating the tree construction up to that point
     * and capturing the sideNodes at each level
     */
    async generateProof(leafIndex: number): Promise<{
        leaf: bigint;
        index: number;
        root: bigint;
        siblings: bigint[];
        depth: number;
    }> {
        if (leafIndex < 0 || leafIndex >= this.size) {
            throw new Error(`Index ${leafIndex} out of bounds (size: ${this.size})`);
        }

        // Rebuild tree incrementally and capture sideNodes at each step
        const tempTree = new LeanIMTContract();
        const sideNodesAtInsertion: bigint[][] = [];

        for (let i = 0; i < this.size; i++) {
            // Capture sideNodes BEFORE inserting this leaf
            if (i === leafIndex) {
                sideNodesAtInsertion.push([...tempTree.sideNodes]);
            }
            await tempTree.insert(this.leaves[i]);
        }

        const siblings: bigint[] = [];
        const capturedSideNodes = sideNodesAtInsertion[0];

        // For the proof, we need the sibling at each level
        // The sibling depends on which side of the tree we're on
        let idx = leafIndex;
        for (let level = 0; level < this.depth; level++) {
            const bit = (idx >> level) & 1;

            if (bit === 1) {
                // We're on the right: sibling is the left node (from sideNodes)
                siblings.push(capturedSideNodes[level]);
            } else {
                // We're on the left: sibling is on the right
                // Need to find the sibling by looking at what was inserted after us
                const siblingIndex = leafIndex ^ (1 << level);
                if (siblingIndex < this.size) {
                    // Sibling exists - we need to compute what hash was at this position
                    // after all insertions up to siblingIndex
                    const siblingTree = new LeanIMTContract();
                    for (let j = 0; j <= siblingIndex; j++) {
                        await siblingTree.insert(this.leaves[j]);
                    }
                    // The sibling is the node that was at sideNodes[level] after siblingIndex was inserted
                    // But for a right sibling, we need the actual hash at that position
                    // Actually, for Lean IMT, if we're on the left and there's no right sibling yet,
                    // we use 0 (no sibling)

                    // Simpler approach: rebuild the tree structure and compute proper siblings
                    siblings.push(await this.computeSiblingAtLevel(leafIndex, level));
                } else {
                    // No sibling (we're the rightmost node)
                    siblings.push(BigInt(0));
                }
            }
        }

        return {
            leaf: this.leaves[leafIndex],
            index: leafIndex,
            root: this.root,
            siblings,
            depth: this.depth,
        };
    }

    /**
     * Compute the sibling hash at a specific level for a given leaf index
     * This properly handles the Lean IMT structure
     */
    private async computeSiblingAtLevel(leafIndex: number, level: number): Promise<bigint> {
        const bit = (leafIndex >> level) & 1;

        if (bit === 1) {
            // We're on the right side - need the left sibling
            // The left sibling is the hash of all leaves in the left subtree at this level
            const subtreeSize = 1 << level;
            const leftSubtreeStart = (leafIndex >> level) * subtreeSize - subtreeSize;
            const leftSubtreeEnd = leftSubtreeStart + subtreeSize;

            // Build the left subtree hash
            return await this.computeSubtreeHash(leftSubtreeStart, Math.min(leftSubtreeEnd, this.size), level);
        } else {
            // We're on the left side - need the right sibling
            const subtreeSize = 1 << level;
            const rightSubtreeStart = ((leafIndex >> level) + 1) * subtreeSize;
            const rightSubtreeEnd = rightSubtreeStart + subtreeSize;

            if (rightSubtreeStart >= this.size) {
                // No right sibling exists
                return BigInt(0);
            }

            // Build the right subtree hash
            return await this.computeSubtreeHash(rightSubtreeStart, Math.min(rightSubtreeEnd, this.size), level);
        }
    }

    /**
     * Compute hash of a subtree from startIdx to endIdx
     */
    private async computeSubtreeHash(startIdx: number, endIdx: number, targetLevel: number): Promise<bigint> {
        if (startIdx >= endIdx || startIdx >= this.size) {
            return BigInt(0);
        }

        // For a single leaf, return it directly
        if (endIdx - startIdx === 1) {
            return this.leaves[startIdx];
        }

        // Build the subtree level by level
        let currentLevel = this.leaves.slice(startIdx, endIdx);

        for (let l = 0; l < targetLevel; l++) {
            const nextLevel: bigint[] = [];
            for (let i = 0; i < currentLevel.length; i += 2) {
                if (i + 1 < currentLevel.length) {
                    nextLevel.push(await poseidon2HashAsync([currentLevel[i], currentLevel[i + 1]]));
                } else {
                    // Odd node - in Lean IMT, it gets promoted
                    nextLevel.push(currentLevel[i]);
                }
            }
            currentLevel = nextLevel;
            if (currentLevel.length === 0) break;
        }

        return currentLevel.length > 0 ? currentLevel[0] : BigInt(0);
    }
}

/**
 * Simple Lean IMT - traditional bottom-up construction
 * Kept for reference/verification
 */
export class SimpleLeanIMT {
    leaves: bigint[];
    root: bigint;
    depth: number;
    tree: bigint[][];

    constructor(leaves: bigint[]) {
        this.leaves = leaves;
        this.tree = [];
        this.root = BigInt(0);
        this.depth = 0;
    }

    async build(): Promise<void> {
        if (this.leaves.length === 0) {
            throw new Error("Cannot build tree with no leaves");
        }

        // Start with leaves as first level
        this.tree.push([...this.leaves]);
        let currentLevel = [...this.leaves];

        // Build tree bottom-up
        while (currentLevel.length > 1) {
            const nextLevel: bigint[] = [];

            for (let i = 0; i < currentLevel.length; i += 2) {
                if (i + 1 < currentLevel.length) {
                    // Both children exist: hash them
                    const hash = await poseidon2HashAsync([currentLevel[i], currentLevel[i + 1]]);
                    nextLevel.push(hash);
                } else {
                    // Only left child exists (Lean IMT property): copy it
                    nextLevel.push(currentLevel[i]);
                }
            }

            this.tree.push(nextLevel);
            currentLevel = nextLevel;
        }

        this.root = currentLevel[0];
        this.depth = this.tree.length - 1;
    }

    async generateProof(index: number, contractDepth?: number): Promise<{ leaf: bigint; index: number; root: bigint; siblings: bigint[] }> {
        if (index < 0 || index >= this.leaves.length) {
            throw new Error(`Index ${index} out of bounds`);
        }

        // Use contract depth if provided (MIN_TREE_DEPTH=8), otherwise use natural depth
        // This is critical: contract always uses at least MIN_TREE_DEPTH=8
        const treeDepth = contractDepth !== undefined ? contractDepth : this.depth;
        if (treeDepth < MIN_TREE_DEPTH) {
            throw new Error(`Tree depth must be at least ${MIN_TREE_DEPTH}, got ${treeDepth}`);
        }

        const siblings: bigint[] = [];

        // Rebuild the full tree level by level (bottom-up) to extract siblings correctly
        // This matches the Solidity contract's generateProof logic exactly
        let levelNodes: bigint[] = [...this.leaves];

        // Build tree level by level and extract siblings at each level
        for (let level = 0; level < treeDepth; level++) {
            const nodeIndex = index >> level;

            // Extract sibling based on whether we're left or right child
            if ((nodeIndex & 1) === 1) {
                // Right child: sibling is on the left
                siblings.push((nodeIndex > 0 && nodeIndex - 1 < levelNodes.length) ? levelNodes[nodeIndex - 1] : BigInt(0));
            } else {
                // Left child: sibling is on the right (if exists)
                siblings.push((nodeIndex + 1 < levelNodes.length) ? levelNodes[nodeIndex + 1] : BigInt(0));
            }

            // Build next level for next iteration
            if (level + 1 < treeDepth) {
                const levelSize = levelNodes.length;
                const nextSize = Math.floor((levelSize - 1) / 2) + 1;
                const nextLevel: bigint[] = [];

                for (let i = 0; i < nextSize; i++) {
                    const leftIdx = i * 2;
                    const rightIdx = leftIdx + 1;

                    const leftNode = levelNodes[leftIdx];
                    let rightNode = BigInt(0);

                    if (rightIdx < levelSize) {
                        rightNode = levelNodes[rightIdx];
                    }

                    if (rightNode !== BigInt(0)) {
                        nextLevel.push(await poseidon2HashAsync([leftNode, rightNode]));
                    } else {
                        nextLevel.push(leftNode);
                    }
                }

                levelNodes = nextLevel;
            }
        }

        return {
            leaf: this.leaves[index],
            index,
            root: this.root,
            siblings
        };
    }

    async verifyProof(proof: { leaf: bigint; index: number; root: bigint; siblings: bigint[] }): Promise<boolean> {
        let currentHash = proof.leaf;
        let currentIndex = proof.index;

        for (let i = 0; i < proof.siblings.length; i++) {
            const sibling = proof.siblings[i];
            const isRightChild = currentIndex % 2 === 1;

            if (isRightChild) {
                // Current node is right child
                currentHash = await poseidon2HashAsync([sibling, currentHash]);
            } else {
                // Current node is left child
                if (sibling !== BigInt(0)) {
                    currentHash = await poseidon2HashAsync([currentHash, sibling]);
                }
                // If sibling is 0, it means no right child (Lean IMT), so current hash stays the same
            }

            currentIndex = Math.floor(currentIndex / 2);
        }

        return currentHash === proof.root;
    }

    get size(): number {
        return this.leaves.length;
    }
}

/**
 * Verify a merkle proof with a specific tree depth (mimics circuit verification)
 */
export async function verifyProofWithDepth(
    leaf: bigint,
    index: number,
    treeDepth: number,
    expectedRoot: bigint,
    proof: bigint[]
): Promise<boolean> {
    let current = leaf;
    let indexCopy = index;

    for (let level = 0; level < treeDepth; level++) {
        const bit = indexCopy % 2;
        const sibling = proof[level] ?? BigInt(0);

        if (bit === 1) {
            // Right child: hash(sibling, current)
            current = await poseidon2HashAsync([sibling, current]);
        } else {
            // Left child: if sibling exists, hash(current, sibling), else current stays
            if (sibling !== BigInt(0)) {
                current = await poseidon2HashAsync([current, sibling]);
            }
            // If sibling is 0, current stays the same (lean-IMT behavior)
        }

        indexCopy = Math.floor(indexCopy / 2);
    }

    return current === expectedRoot;
}

/**
 * Generate a Merkle proof for a leaf at a given index
 * 
 * This function EXACTLY matches the Solidity test contract's generateProof logic
 * from MerkleTreeTest.t.sol (lines 71-137)
 * 
 * @param leaves - Array of all leaves in the tree (must be in insertion order)
 * @param leafIndex - Index of the leaf to prove (0-based)
 * @param expectedDepth - Expected depth to pad siblings to (default 32)
 * @returns Merkle proof with siblings padded to expectedDepth
 */
export async function generateMerkleProof(
    leaves: bigint[],
    leafIndex: number,
    expectedDepth: number = 32
): Promise<{
    leaf: bigint;
    index: number;
    root: bigint;
    siblings: string[];
    depth: number;
}> {
    if (leafIndex < 0 || leafIndex >= leaves.length) {
        throw new Error(`Leaf index ${leafIndex} out of bounds (leaves.length: ${leaves.length})`);
    }

    // Build tree using contract logic to get the correct depth and root
    const contractTree = new LeanIMTContract();
    await contractTree.buildFromLeaves(leaves);

    const treeDepth = contractTree.depth;
    if (treeDepth < MIN_TREE_DEPTH) {
        throw new Error(`Tree depth must be at least ${MIN_TREE_DEPTH}, got ${treeDepth}`);
    }

    console.log(`ðŸŒ³ Generating proof for leaf[${leafIndex}] in tree with ${leaves.length} leaves, depth=${treeDepth}`);

    // EXACTLY match Solidity: proof = new uint256[](treeDepth);
    const proof: bigint[] = new Array(treeDepth);

    // EXACTLY match Solidity: Build tree level by level (bottom-up) to extract siblings correctly
    // uint256[] memory levelNodes = new uint256[](leaves.length);
    let levelNodes: bigint[] = [...leaves];

    // EXACTLY match Solidity: Build tree level by level and extract siblings at each level
    // for (uint256 level = 0; level < treeDepth; level++) {
    for (let level = 0; level < treeDepth; level++) {
        // EXACTLY match Solidity: uint256 bit = (leafIndex >> level) & 1;
        // EXACTLY match Solidity: uint256 nodeIndex = leafIndex >> level;
        const bit = (leafIndex >> level) & 1;
        const nodeIndex = leafIndex >> level;

        // EXACTLY match Solidity logic for extracting siblings
        if (bit === 1) {
            // Right child: sibling is on the left
            // if (nodeIndex > 0 && nodeIndex - 1 < levelNodes.length) {
            //     proof[level] = levelNodes[nodeIndex - 1];
            // } else {
            //     proof[level] = 0;
            // }
            if (nodeIndex > 0 && nodeIndex - 1 < levelNodes.length) {
                proof[level] = levelNodes[nodeIndex - 1];
            } else {
                proof[level] = BigInt(0);
            }
        } else {
            // Left child: sibling is on the right (if exists)
            // if (nodeIndex + 1 < levelNodes.length) {
            //     proof[level] = levelNodes[nodeIndex + 1];
            // } else {
            //     proof[level] = 0;
            // }
            if (nodeIndex + 1 < levelNodes.length) {
                proof[level] = levelNodes[nodeIndex + 1];
            } else {
                proof[level] = BigInt(0);
            }
        }

        // EXACTLY match Solidity: Build next level for next iteration
        // if (level < treeDepth - 1) {
        if (level < treeDepth - 1) {
            // uint256 levelSize = levelNodes.length;
            // uint256 nextSize = ((levelSize - 1) / 2) + 1;
            const levelSize = levelNodes.length;
            const nextSize = Math.floor((levelSize - 1) / 2) + 1;
            const nextLevel: bigint[] = [];

            // for (uint256 i = 0; i < nextSize; i++) {
            for (let i = 0; i < nextSize; i++) {
                // uint256 leftIdx = i * 2;
                // uint256 rightIdx = i * 2 + 1;
                const leftIdx = i * 2;
                const rightIdx = leftIdx + 1;

                // uint256 leftNode = levelNodes[leftIdx];
                // uint256 rightNode = 0;
                const leftNode = levelNodes[leftIdx];
                let rightNode = BigInt(0);

                // if (rightIdx < levelSize) {
                //     rightNode = levelNodes[rightIdx];
                // }
                if (rightIdx < levelSize) {
                    rightNode = levelNodes[rightIdx];
                }

                // if (rightNode != 0) {
                //     nextLevel[i] = _hash2(leftNode, rightNode);
                // } else {
                //     nextLevel[i] = leftNode;
                // }
                if (rightNode !== BigInt(0)) {
                    nextLevel[i] = await poseidon2HashAsync([leftNode, rightNode]);
                } else {
                    nextLevel[i] = leftNode;
                }
            }

            levelNodes = nextLevel;
        }
    }

    // Pad siblings to expectedDepth with zeros (for circuit compatibility)
    const paddedSiblings: string[] = [];
    for (let i = 0; i < expectedDepth; i++) {
        if (i < proof.length) {
            paddedSiblings.push(proof[i].toString());
        } else {
            paddedSiblings.push('0');
        }
    }

    console.log(`âœ… Generated proof: ${proof.length} siblings (padded to ${expectedDepth})`);

    // Verify the proof matches the contract's root
    const isValid = await verifyProofWithDepth(
        leaves[leafIndex],
        leafIndex,
        treeDepth,
        contractTree.root,
        proof
    );

    if (!isValid) {
        console.error(`âŒ Generated proof does not verify against contract root!`);
        throw new Error(`Proof verification failed for leaf[${leafIndex}]`);
    }

    console.log(`âœ… Proof verified against contract root`);

    return {
        leaf: leaves[leafIndex],
        index: leafIndex,
        root: contractTree.root,
        siblings: paddedSiblings,
        depth: treeDepth,
    };
}
