// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Test, console} from "forge-std/Test.sol";

/**
 * @title DrandTest
 * @notice Test to verify drand timelock encryption with on-chain pairing verification
 * @dev AUTO-GENERATED by scripts/drand-sync.sh - DO NOT EDIT MANUALLY
 *
 * ZERO TRUST verification:
 * BEFORE round: e(V, G2_gen) * e(-H, C1) == 1 (proves V = r*H, C1 = r*G2)
 * AFTER round:  e(sigma, C1) * e(-V, drand_pubkey) == 1 (proves correct pubkey)
 */
contract DrandTest is Test {
    // BN254 field modulus
    uint256 public constant BN254_FIELD_MODULUS = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;

    // BN254 pairing precompile address
    address public constant BN254_PAIRING_PRECOMPILE = address(0x08);

    // BN254 G2 generator (standard values)
    // Format: x = x_c0 + x_c1*i, y = y_c0 + y_c1*i
    // Precompile expects: (x_c1, x_c0, y_c1, y_c0)
    uint256 public constant G2_X_C1 = 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2; // imaginary
    uint256 public constant G2_X_C0 = 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed; // real
    uint256 public constant G2_Y_C1 = 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b; // imaginary
    uint256 public constant G2_Y_C0 = 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa; // real

    // Evmnet drand public key (BN254 G2)
    // From drand JSON pubkey hex, format is: (x_c1, x_c0, y_c1, y_c0)
    // Precompile expects same order: (x_c1, x_c0, y_c1, y_c0)
    uint256 public constant EVMNET_PK_X_C1 = 0x07e1d1d335df83fa98462005690372c643340060d205306a9aa8106b6bd0b382; // imaginary
    uint256 public constant EVMNET_PK_X_C0 = 0x0557ec32c2ad488e4d4f6008f89a346f18492092ccc0d594610de2732c8b808f; // real
    uint256 public constant EVMNET_PK_Y_C1 = 0x0095685ae3a85ba243747b1b2f426049010f6b73a0cf1d389351d5aaaa1047f6; // imaginary
    uint256 public constant EVMNET_PK_Y_C0 = 0x297d3a4f9749b33eb2d904c9d9ebf17224150ddd7abd7567a9bec6c74480ee0b; // real

    struct TimelockProof {
        uint256 targetRound;
        uint256 H_x; // G1 point: hash_to_curve(round)
        uint256 H_y;
        uint256 V_x; // G1 point: r * H
        uint256 V_y;
        uint256 C1_x0; // G2 point: r * G2_gen (real part)
        uint256 C1_x1; // (imaginary part)
        uint256 C1_y0; // (real part)
        uint256 C1_y1; // (imaginary part)
        uint256 pairingResult;
        uint256 ciphertext;
    }

    /**
     * @notice Verify BEFORE round: e(V, G2_gen) * e(-H, C1) == 1
     * @dev This proves V = r*H and C1 = r*G2 for the same r
     */
    function verifyPairingBeforeRound(TimelockProof memory proof) public view returns (bool) {
        // Negate H (negate y coordinate in Fp)
        uint256 neg_H_y = BN254_FIELD_MODULUS - (proof.H_y % BN254_FIELD_MODULUS);

        // Build pairing input: e(V, G2_gen) * e(-H, C1)
        // Format per EIP-197: (G1_x, G1_y, G2_x_c1, G2_x_c0, G2_y_c1, G2_y_c0)
        bytes memory input = abi.encodePacked(
            // Pair 1: (V, G2_gen)
            proof.V_x,
            proof.V_y,
            G2_X_C1,
            G2_X_C0, // x_c1 (imag), x_c0 (real)
            G2_Y_C1,
            G2_Y_C0, // y_c1 (imag), y_c0 (real)
            // Pair 2: (-H, C1)
            proof.H_x,
            neg_H_y,
            proof.C1_x1,
            proof.C1_x0, // C1_x1 is c1 (imag), C1_x0 is c0 (real)
            proof.C1_y1,
            proof.C1_y0 // C1_y1 is c1 (imag), C1_y0 is c0 (real)
        );

        (bool success, bytes memory result) = BN254_PAIRING_PRECOMPILE.staticcall(input);

        if (!success || result.length != 32) {
            return false;
        }

        return abi.decode(result, (uint256)) == 1;
    }

    /**
     * @notice Verify AFTER round: e(sigma, C1) * e(-V, drand_pubkey) == 1
     * @dev This proves the encryption used the correct drand pubkey
     */
    function verifyPairingAfterRound(TimelockProof memory proof, uint256 sigma_x, uint256 sigma_y)
        public
        view
        returns (bool)
    {
        // Negate V (negate y coordinate in Fp)
        uint256 neg_V_y = BN254_FIELD_MODULUS - (proof.V_y % BN254_FIELD_MODULUS);

        // Build pairing input: e(sigma, C1) * e(-V, drand_pubkey)
        // Format per EIP-197: (G1_x, G1_y, G2_x_c1, G2_x_c0, G2_y_c1, G2_y_c0)
        bytes memory input = abi.encodePacked(
            // Pair 1: (sigma, C1)
            sigma_x,
            sigma_y,
            proof.C1_x1,
            proof.C1_x0, // C1_x1 is c1 (imag), C1_x0 is c0 (real)
            proof.C1_y1,
            proof.C1_y0, // C1_y1 is c1 (imag), C1_y0 is c0 (real)
            // Pair 2: (-V, drand_pubkey)
            proof.V_x,
            neg_V_y,
            EVMNET_PK_X_C1,
            EVMNET_PK_X_C0, // x_c1 (imag), x_c0 (real)
            EVMNET_PK_Y_C1,
            EVMNET_PK_Y_C0 // y_c1 (imag), y_c0 (real)
        );

        (bool success, bytes memory result) = BN254_PAIRING_PRECOMPILE.staticcall(input);

        if (!success || result.length != 32) {
            return false;
        }

        return abi.decode(result, (uint256)) == 1;
    }

    /**
     * @notice Test BEFORE round pairing verification
     * @dev Uses values from TypeScript timelock-prep.js via drand-sync.sh
     */
    function test_VerifyPairingBeforeRound() public {
        // AUTO-GENERATED VALUES - DO NOT EDIT MANUALLY
        TimelockProof memory proof = TimelockProof({
            targetRound: 0xd8173f,
            H_x: 0x25d3f92d5d6b7b15cd6360cd746b5001e3ffd7bb0c6d3949158a0214a8d8b268,
            H_y: 0xb11034b64b10d4cdff425fba3d857e96cd23738789e68df5d64ccca881c8b05,
            V_x: 0x783acf9cadf136444573178ba540c058d95b61a13534e7a502519e2b61f4a82,
            V_y: 0xe33c8f04f0bd7d88455203080b3fc81164f11d9afecf1da64e2a422d0fcb8e3,
            C1_x0: 0x923e1d4de1ad26d2258943a10f8cee94fc5516be3074fd75b494ae72e8bbb39,
            C1_x1: 0x2fa991f9d9654a6fe03a19c891e3f8298e59e7d579907c23766e8c071a99607d,
            C1_y0: 0x1f86545bd5d6b6cd70010f39e89725793cfb578a9aa37d88c64a039b40e4f1a,
            C1_y1: 0x5ddbacaa77db26735b8554c800cbf0f159a85a2e5ec71dffbaffbffaf4574f7,
            pairingResult: 0x107b5ed0db8d82f8e13cd635f33dc1ba12d85cb4baa964af52bf429114f15c2b,
            ciphertext: 0x2952ef0fd431cd2deb9e257e6f856635a56a9576c04e911e0ee83eeda6aae976
        });

        // Verify before round: proves V = r*H and C1 = r*G2
        bool valid = verifyPairingBeforeRound(proof);
        assertTrue(valid, "BEFORE round pairing check failed: e(V, G2_gen) * e(-H, C1) != 1");

        console.log("BEFORE round verification PASSED!");
        console.log("Proven: V = r*H and C1 = r*G2 for same r");
    }
}
